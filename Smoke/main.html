<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script>
    <style>
        /* We want our scene to span the entire window */
        body { margin: 0; }
    </style>
</heda>
<body>
    
    <script id="fragShader" type="shader-code">
        uniform vec2 resolution;
        uniform sampler2D bufferTexture;
        uniform vec3 smokeSource;
        uniform float time;

        void main() {
            vec2 pixel = gl_FragCoord.xy / resolution.xy;
            gl_FragColor = texture2D( bufferTexture, pixel );

            //Get the distance of this pixel from the center of the screen
            float dist = distance(smokeSource.xy, gl_FragCoord.xy);
            gl_FragColor.rgb += smokeSource.z * max(15.0-dist,0.0);

            float xPixel = 1.0/resolution.x;
            float yPixel = 1.0/resolution.y;

            vec4 rightColor = texture2D(bufferTexture, vec2(pixel.x+xPixel, pixel.y));
            vec4 leftColor = texture2D(bufferTexture, vec2(pixel.x-xPixel, pixel.y));
            vec4 upColor = texture2D(bufferTexture, vec2(pixel.x, pixel.y+yPixel));
            vec4 downColor = texture2D(bufferTexture, vec2(pixel.x, pixel.y-yPixel));

            float factor = 14.0 * 0.016 * (leftColor.r + rightColor.r + upColor.r + downColor.r - 4.0 * gl_FragColor.r);
            float minimum = 0.003;
            if (factor >= -minimum && factor < 0.0) factor = -minimum;
            gl_FragColor.rgb += factor;
        }
    </script>

    <script>
        //@author Omar Shehata. 2015.
        //@Edited Daniel Rodriguez. 2018.
        //We are loading the Three.js library from the cdn here: http://cdnjs.com/libraries/three.js/
        var scene;
        var camera;
        var renderer;

        function scene_setup(){
            //This is all code needed to set up a basic ThreeJS scene
            //First we initialize the scene and our camera
            scene = new THREE.Scene();
            var width = window.innerWidth;
            var height = window.innerHeight;
            camera = new THREE.OrthographicCamera( width / -2, width / 2, height / 2, height / -2, 1, 1000 );
            camera.position.z = 2;
            //We create the WebGL renderer and add it to the document
            renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
        }

        scene_setup();

        var bufferScene;
        var textureA;
        var textureB;
        var bufferMaterial;
        var plane;
        var bufferObject;
        var finalMaterial;
        var quad;

        function buffer_texture_setup(){
            //Create buffer scene
            bufferScene = new THREE.Scene();
            //Create 2 buffer textures
            textureA = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
            textureB = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter} );
            //Pass textureA to shader
            bufferMaterial = new THREE.ShaderMaterial( {
                uniforms: {
                 bufferTexture: { type: "t", value: textureA },
                 resolution: {type: 'v2', value: new THREE.Vector2(window.innerWidth,window.innerHeight)},//Keeps the resolution
                 smokeSource: {type: 'v3', value: new THREE.Vector3(0.0)},
                 time: {type: 'f', value: 0.0}
                },
                fragmentShader: document.getElementById( 'fragShader' ).innerHTML
            } );
            plane = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight );
            bufferObject = new THREE.Mesh( plane, bufferMaterial );
            bufferScene.add(bufferObject);

            //Draw textureB to screen 
            finalMaterial =  new THREE.MeshBasicMaterial({map: textureB});
            quad = new THREE.Mesh( plane, finalMaterial );
            scene.add(quad);
        }
        buffer_texture_setup();

        var globalTime = new Date().getTime();

        document.onmousemove = function(event){
            //Update the light source to follow our mouse
            bufferMaterial.uniforms.smokeSource.value.x = event.clientX; 
            bufferMaterial.uniforms.smokeSource.value.y = window.innerHeight - event.clientY; 
        }

        document.onmousedown = function(event){
            //Update the light source to follow our mouse
            bufferMaterial.uniforms.smokeSource.value.z = 0.1;
            console.log("mousedown");
            console.log(bufferMaterial.uniforms.smokeSource.value);
        }

        document.onmouseup = function(event){
            //Update the light source to follow our mouse
            bufferMaterial.uniforms.smokeSource.value.z = 0.0;
            console.log("mouseup");
        }

        //Render everything!
        function render() {

            requestAnimationFrame( render );
          
            //Draw to textureB
            renderer.render(bufferScene,camera,textureB,true);
            
            //Swap textureA and B
            var t = textureA;
            textureA = textureB;
            textureB = t;
            quad.material.map = textureB;
            bufferMaterial.uniforms.bufferTexture.value = textureA;

            //Finally, draw to the screen
            renderer.render( scene, camera );

        }
        render();

    </script>
</body>
</html>